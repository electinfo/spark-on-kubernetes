---
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: spark-images-build
  namespace: tekton-pipelines
spec:
  description: Build all Spark/Zeppelin images using docker buildx bake
  params:
    - name: git-url
      type: string
      default: "https://github.com/electinfo/spark-on-kubernetes.git"
    - name: git-revision
      type: string
      default: "main"
    - name: registry
      type: string
      default: "registry.container-registry.svc.cluster.local:5000"
    - name: tag
      type: string
      default: "latest"
    - name: targets
      type: string
      default: "default"
      description: "Build targets: default, spark-images, zeppelin-images, or specific target"
  workspaces:
    - name: shared-workspace
  tasks:
    - name: fetch-source
      taskRef:
        name: electinfo-git-clone
      params:
        - name: repo-url
          value: $(params.git-url)
        - name: revision
          value: $(params.git-revision)
      workspaces:
        - name: source
          workspace: shared-workspace

    - name: get-old-digests
      runAfter:
        - fetch-source
      taskRef:
        name: spark-images-get-digests
      params:
        - name: registry
          value: $(params.registry)

    - name: build-images
      runAfter:
        - get-old-digests
      taskRef:
        name: docker-buildx-bake
      params:
        - name: registry
          value: $(params.registry)
        - name: tag
          value: $(params.tag)
        - name: targets
          value: $(params.targets)
        - name: old-spark-connect-digest
          value: $(tasks.get-old-digests.results.spark-connect-server-digest)
        - name: old-zeppelin-server-digest
          value: $(tasks.get-old-digests.results.zeppelin-server-digest)
        - name: old-spark-runner-digest
          value: $(tasks.get-old-digests.results.spark-runner-digest)
      workspaces:
        - name: source
          workspace: shared-workspace

    - name: restart-spark-connect
      runAfter:
        - build-images
      when:
        - input: $(tasks.build-images.results.spark-connect-changed)
          operator: in
          values: ["true"]
      taskRef:
        name: electinfo-restart-deployment
      params:
        - name: deployment-name
          value: spark-connect-server
        - name: namespace
          value: spark
        - name: argocd-app
          value: app-spark-connect

    - name: restart-zeppelin
      runAfter:
        - build-images
      when:
        - input: $(tasks.build-images.results.zeppelin-server-changed)
          operator: in
          values: ["true"]
      taskRef:
        name: electinfo-restart-deployment
      params:
        - name: deployment-name
          value: zeppelin-server
        - name: namespace
          value: zeppelin
        - name: argocd-app
          value: app-zeppelin

    - name: restart-spark-runner
      runAfter:
        - build-images
      when:
        - input: $(tasks.build-images.results.spark-runner-changed)
          operator: in
          values: ["true"]
      taskRef:
        name: electinfo-restart-deployment
      params:
        - name: deployment-name
          value: spark-runner
        - name: namespace
          value: spark
        - name: argocd-app
          value: util-spark-runner

  finally:
    - name: refresh-rundeck-nodes
      taskRef:
        name: refresh-rundeck-nodes
---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: refresh-rundeck-nodes
  namespace: tekton-pipelines
spec:
  description: Refresh Rundeck Kubernetes node cache after deployments restart
  steps:
    - name: refresh
      image: bitnami/kubectl:latest
      script: |
        #!/bin/sh

        echo "Refreshing Rundeck node cache..."

        # Wait for Rundeck pod to be ready (may have been restarted)
        WAITED=0
        MAX_WAIT=120
        RD_POD=""
        while [ $WAITED -lt $MAX_WAIT ]; do
          RD_POD=$(kubectl get pods -n rundeck --field-selector=status.phase=Running \
            -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null \
            | grep -m1 rundeck || echo "")
          if [ -n "$RD_POD" ]; then
            READY=$(kubectl get pod "$RD_POD" -n rundeck \
              -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null)
            if [ "$READY" = "True" ]; then
              break
            fi
          fi
          echo "  Waiting for Rundeck pod to be ready... (${WAITED}s)"
          sleep 10
          WAITED=$((WAITED + 10))
        done

        if [ -z "$RD_POD" ]; then
          echo "WARNING: Rundeck pod not ready after ${MAX_WAIT}s, skipping refresh"
          exit 0
        fi
        echo "Found Rundeck pod: $RD_POD"

        # Use rd CLI inside the Rundeck pod to list nodes (forces cache refresh)
        echo "Querying spark nodes to refresh cache..."
        kubectl exec -n rundeck "$RD_POD" -c util-rundeck -- \
          rd nodes list -p electinfo -F "spark-runner" 2>&1 || true
        kubectl exec -n rundeck "$RD_POD" -c util-rundeck -- \
          rd nodes list -p electinfo -F "spark-connect" 2>&1 || true

        # Brief wait then verify
        sleep 3
        echo "Current spark-runner nodes:"
        kubectl exec -n rundeck "$RD_POD" -c util-rundeck -- \
          rd nodes list -p electinfo -F "spark-runner" 2>&1 || true
        echo "Rundeck node refresh complete"
---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: spark-images-get-digests
  namespace: tekton-pipelines
spec:
  description: Get current image digests before building
  params:
    - name: registry
      type: string
      default: "registry.container-registry.svc.cluster.local:5000"
  results:
    - name: spark-connect-server-digest
      description: Current digest of spark-connect-server image
    - name: zeppelin-server-digest
      description: Current digest of zeppelin-server image
    - name: spark-runner-digest
      description: Current digest of spark-runner image
  steps:
    - name: get-digests
      image: gcr.io/go-containerregistry/crane:debug
      script: |
        #!/busybox/sh
        set -e
        REGISTRY="$(params.registry)"

        echo "Getting current digests..."

        # spark-connect-server
        DIGEST=$(crane digest "$REGISTRY/electinfo/spark-connect-server:latest" --insecure 2>/dev/null || echo "none")
        echo "spark-connect-server: $DIGEST"
        echo -n "$DIGEST" > $(results.spark-connect-server-digest.path)

        # zeppelin-server
        DIGEST=$(crane digest "$REGISTRY/electinfo/zeppelin-server:latest" --insecure 2>/dev/null || echo "none")
        echo "zeppelin-server: $DIGEST"
        echo -n "$DIGEST" > $(results.zeppelin-server-digest.path)

        # spark-runner
        DIGEST=$(crane digest "$REGISTRY/electinfo/spark-runner:latest" --insecure 2>/dev/null || echo "none")
        echo "spark-runner: $DIGEST"
        echo -n "$DIGEST" > $(results.spark-runner-digest.path)

        echo "Done getting digests"
---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: docker-buildx-bake
  namespace: tekton-pipelines
spec:
  description: Build Docker images using docker buildx bake with DinD sidecar
  params:
    - name: registry
      type: string
      default: "registry.container-registry.svc.cluster.local:5000"
    - name: tag
      type: string
      default: "latest"
    - name: targets
      type: string
      default: "default"
    - name: dind-image
      type: string
      default: "docker:27-dind"
    - name: old-spark-connect-digest
      type: string
      default: "none"
    - name: old-zeppelin-server-digest
      type: string
      default: "none"
    - name: old-spark-runner-digest
      type: string
      default: "none"
  results:
    - name: spark-connect-changed
      description: Whether spark-connect-server image changed (true or false)
    - name: zeppelin-server-changed
      description: Whether zeppelin-server image changed (true or false)
    - name: spark-runner-changed
      description: Whether spark-runner image changed (true or false)
  workspaces:
    - name: source
  sidecars:
    - name: docker
      image: $(params.dind-image)
      args:
        - "--tls=false"
        - "--insecure-registry=registry.container-registry.svc.cluster.local:5000"
      securityContext:
        privileged: true
      env:
        - name: DOCKER_TLS_CERTDIR
          value: ""
      volumeMounts:
        - name: docker-socket
          mountPath: /var/run
        - name: dind-storage
          mountPath: /var/lib/docker
      readinessProbe:
        periodSeconds: 1
        exec:
          command: ["docker", "info"]
  steps:
    - name: bake
      image: docker:27-cli
      workingDir: $(workspaces.source.path)
      env:
        - name: DOCKER_HOST
          value: unix:///var/run/docker.sock
        - name: DOCKER_BUILDKIT
          value: "1"
      script: |
        #!/bin/sh
        set -ex

        # Wait for docker daemon (needed for buildx CLI)
        echo "Waiting for Docker daemon..."
        until docker info; do
          sleep 1
        done

        # Export variables for docker-bake.hcl
        export REGISTRY="$(params.registry)"
        export TAG="$(params.tag)"

        # Create buildkitd config for insecure registry
        mkdir -p /tmp/buildkit
        cat > /tmp/buildkit/buildkitd.toml <<-'EOF'
        [registry."registry.container-registry.svc.cluster.local:5000"]
          http = true
          insecure = true
        EOF

        # Remove any existing builder to ensure fresh config
        docker buildx rm k8s-builder 2>/dev/null || true

        # Create a kubernetes driver builder
        docker buildx create \
          --name k8s-builder \
          --driver kubernetes \
          --driver-opt namespace=tekton-pipelines \
          --driver-opt replicas=1 \
          --config /tmp/buildkit/buildkitd.toml \
          --use

        docker buildx inspect --bootstrap

        # Build all targets with a single bake command
        TARGETS="$(params.targets)"
        echo "=== Building targets: $TARGETS ==="
        docker buildx bake --file docker-bake.hcl --push $TARGETS

        echo "Build complete!"
      volumeMounts:
        - name: docker-socket
          mountPath: /var/run
    - name: check-changes
      image: gcr.io/go-containerregistry/crane:debug
      script: |
        #!/busybox/sh
        set -e
        REGISTRY="$(params.registry)"

        echo "Checking for image changes..."

        # spark-connect-server
        OLD="$(params.old-spark-connect-digest)"
        NEW=$(crane digest "$REGISTRY/electinfo/spark-connect-server:latest" --insecure 2>/dev/null || echo "error")
        echo "spark-connect-server: old=$OLD new=$NEW"
        if [ "$OLD" = "$NEW" ]; then
          echo -n "false" > $(results.spark-connect-changed.path)
        else
          echo -n "true" > $(results.spark-connect-changed.path)
        fi

        # zeppelin-server
        OLD="$(params.old-zeppelin-server-digest)"
        NEW=$(crane digest "$REGISTRY/electinfo/zeppelin-server:latest" --insecure 2>/dev/null || echo "error")
        echo "zeppelin-server: old=$OLD new=$NEW"
        if [ "$OLD" = "$NEW" ]; then
          echo -n "false" > $(results.zeppelin-server-changed.path)
        else
          echo -n "true" > $(results.zeppelin-server-changed.path)
        fi

        # spark-runner
        OLD="$(params.old-spark-runner-digest)"
        NEW=$(crane digest "$REGISTRY/electinfo/spark-runner:latest" --insecure 2>/dev/null || echo "error")
        echo "spark-runner: old=$OLD new=$NEW"
        if [ "$OLD" = "$NEW" ]; then
          echo -n "false" > $(results.spark-runner-changed.path)
        else
          echo -n "true" > $(results.spark-runner-changed.path)
        fi

        echo "Done checking changes"
  volumes:
    - name: docker-socket
      emptyDir: {}
    - name: dind-storage
      emptyDir: {}